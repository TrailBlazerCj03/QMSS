{
    "collab_server" : "",
    "contents" : "---\ntitle: \"Class 2 - Intro to the Tidyverse\"\nsubtitle: Sources - R Tidyverse Vignettes & H. Wickham\nauthor: Michael Parrott\ndate: June 3, 2019\njob: QMSS Modern Data Structures\nmode: selfcontained\nalways_allow_html: yes\n\noutput:\n  ioslides_presentation:\n    incremental: false\n    smaller: false\n    keep_md: true\n\n---\n\n```{r packages, message = FALSE, warning = FALSE, echo=FALSE}\nlibrary(tidyverse)\n```\n\n\n## Working with Tibbles\n\nTibbles are a modern take on data frames. \n\nThey keep the features that have stood the test of time, and drop the features that used to be convenient but are now frustrating (i.e. converting character vectors to factors).\n\n## Creating Tibbles\n\ntibble() is a nice way to create data frames. It encapsulates best practices for data frames:\n\n\n```{r}\n\ntibble(x = letters)\n```\n\n\n## Tibbles Vs. Data Frames\n\nThere are three key differences between tibbles and data frames: \n\nprinting, subsetting, and recycling rules.\n\n## Printing\nWhen you print a tibble, it only shows the first ten rows and all the columns that fit on one screen. \n\nIt also prints an abbreviated description of the column type, and uses font styles and color for highlighting:\n\n## Printing\n```{r}\ntibble(x = -5:1000)\n```\n## Printing\n\nYou can control the default appearance with options:\n\noptions(tibble.print_max = n, tibble.print_min = m): if there are more than n rows, print only the first m rows. \n\nUse options(tibble.print_max = Inf) to always show all rows.\n\noptions(tibble.width = Inf) will always print all columns, regardless of the width of the screen.\n\n## Subsetting\n\nTibbles are quite strict about subsetting. \n\n- always returns another tibble. Contrast this with a data frame: \nsometimes \n- returns a data frame and sometimes it just returns a vector:\n\n```{r}\ndf1 <- data.frame(x = 1:3, y = 3:1)\nclass(df1[, 1:2])\n\nclass(df1[, 1])\n```\n\n## Subsetting\n\n```{r}\ndf2 <- tibble(x = 1:3, y = 3:1)\nclass(df2[, 1:2])\n\nclass(df2[, 1])\n```\n\n## To extract a single column use [[ or $:\n```{r}\nclass(df2[[1]])\n\nclass(df2$x)\n```\n\n## Intro to dplyr package \n\nWhen working with data you must:\n\n- Figure out what you want to do.\n- Describe those tasks in the form of a computer program.\n- Execute the program.\n\n## Intro to dplyr package \n\nThe dplyr package makes these steps fast and easy:\n\nBy constraining your options, it helps you think about your data manipulation challenges.\n\n*It provides simple “verbs”*, functions that correspond to the most common data manipulation tasks, to help you translate your thoughts into code.\n\nIt also uses efficient backends, so you spend less time waiting for the computer.\n\n## Intro to dplyr package \n\nExample data: nycflights13\n\nTo work with data you need to install the nycflights13 package\n\n```{r}\nlibrary(nycflights13)\ndim(flights)\n\nflights\n```\n\n## Single table verbs\n\nDplyr aims to provide a function for each basic verb of data manipulation:\n\n- filter() to select cases based on their values.\n- arrange() to reorder the cases.\n- select() and rename() to select variables based on their names.\n- mutate() and transmute() to add new variables that are functions of existing variables.\n- summarise() to condense multiple values to a single value.\n- sample_n() and sample_frac() to take random samples.\n\n\n## Filter rows with filter()\nfilter() allows you to select a subset of rows in a data frame. \n\nLike all single verbs, the first argument is the tibble (or data frame). \n\nThe second and subsequent arguments refer to variables within that data frame, selecting rows where the expression is TRUE.\n\n## Filter rows with filter()\n\nFor example, we can select all flights on January 1st with:\n\n```{r}\nfilter(flights, month == 1, day == 1)\n```\n\n## Filter rows with filter()\n\nfilter(flights, month == 1, day == 1)\n\nThis is roughly equivalent to this base R code:\n\n```{r}\nflights[flights$month == 1 & flights$day == 1, ]\n```\n\n## Arrange rows with arrange()\narrange() works similarly to filter() except that instead of filtering or selecting rows, it reorders them. \n\nIt takes a data frame, and a set of column names (or more complicated expressions) to order by. \n\nIf you provide more than one column name, each additional column will be used to break ties in the values of preceding columns:\n\narrange(flights, year, month, day)\n\n## Arrange rows with arrange()\n\n```{r}\narrange(flights, year, month, day)\n```\n\n## Arrange rows with arrange()\n\nUse desc() to order a column in descending order:\n\narrange(flights, desc(arr_delay))\n\n## Arrange rows with arrange()\n\n```{r}\narrange(flights, desc(arr_delay))\n```\n\n## Select columns with select()\nOften you work with large datasets with many columns but only a few are actually of interest to you. \n\nselect() allows you to rapidly zoom in on a useful subset of columns\n\n## Select columns by name\n\n```{r}\nselect(flights, year, month, day)\n```\n\n## Select all columns between year and day (inclusive)\n\n```{r}\nselect(flights, year:day)\n```\n\n## Select all columns except those from year to day (inclusive)\n\n```{r}\nselect(flights, -(year:day))\n```\n\n## Helper functions\nThere are a number of helper functions you can use within select(), \n\n- like starts_with(), \n- ends_with(), \n- matches() \n- and contains(). \n\nThese let you quickly match larger blocks of variables that meet some criterion. \nSee ?select for more details.\n\n## Use rename() to change variable names\n\nExample: For original column name \"tailnum\", change it to \"tail_num\"...\n\n```{r}\nrename(flights, tail_num = tailnum)\ncolnames(flights)\n```\n\n## Add new columns with mutate()\nBesides selecting sets of existing columns, it’s often useful to add new columns that are functions of existing columns. \n\nThis is the job of mutate():\n\n```{r}\nmutate(flights,\n  gain = arr_delay - dep_delay,\n  speed = distance / air_time * 60\n)\n```\n\n## More with mutate()\ncase_when is particularly useful inside mutate when you want to\ncreate a new variable that relies on a complex combination of existing\nvariables:\n\n## More with mutate()\n```{r}\nstarwars %>%\n  select(name:mass, gender, species) %>%\n  mutate(\n    type = case_when(\n      height > 200 | mass > 200 ~ \"large\",\n      species == \"Droid\"        ~ \"robot\",\n      TRUE                      ~ \"other\"  \n      # this \"TRUE\" code defines what to define everything                                              # else\n    )\n  )\n```\n\n## Summarise values with summarise()\n\nThe last verb is summarise(). It collapses a data frame to a single row.\n```{r}\nsummarise(flights,\n  delay = mean(dep_delay, na.rm = TRUE)\n)\n```\nIt’s not that useful until we learn the group_by() verb below.\n\n## Calculate stats by variable category\n\nGrouped operations with group_by():\n\nThe dplyr verbs are useful on their own, but they become even more powerful when you apply them to groups of observations within a dataset. \n\nIn dplyr, you do this with the group_by() function.\n\n## group_by() examples:\n\nGroup flights data by values in tailnum column:\n\nby_tailnum <- group_by(flights, tailnum)\n\nGroup flights data by values in dest column:\n\ndestinations <- group_by(flights, dest)\n\n\n## group_by() examples:\n\nWe often use group_by() with the summarise function.\n\nYou use summarise() with aggregate functions, which take a vector of values and return a single number.\n\n```{r}\ndestinations <- group_by(flights, dest)\nsummarise(destinations,\n  planes = n_distinct(tailnum),\n  flights = n()\n)\n```\n## summarise aggregate functions:\n\nYou use summarise() with aggregate functions, which take a vector of values and return a single number. \n\nThere are many useful examples of such functions in base R like ***min(), max(), mean(), sum(), sd(), median(), and IQR().*** \n\ndplyr provides a handful of others:\n\n***n()***: the number of observations in the current group\n\n***n_distinct(x)***:the number of unique values in x.\n\nOthers include - first(x), last(x) and nth(x, n) - these work similarly to x[1], x[length(x)], and x[n] but give you more control over the result if the value is missing.\n\n\n## Use ungroup() to stop grouped operations\n\nungroup(flights)\n\n\n## Pipe Operators and the Tidyverse\n\nYou can use Tidyverse functions with the pipe operator\n\nThe %>% operator is used to make code easier to read\n\n## Different ways to organize code\n\nOption 1: Use multiple objects/variables\n\n```{r}\na <- filter(mtcars, carb > 1)\nb <- group_by(a, cyl)\nc <- summarise(b, Avg_mpg = mean(mpg))\nd <- arrange(c, desc(Avg_mpg))\nprint(d)\n```\n\n## Different ways to organize code\n\nOption 2: Nested Option\n\n```{r}\narrange(\n   summarize(\n       group_by(\n           filter(mtcars, carb > 1),\n           cyl\n          ),\n       Avg_mpg = mean(mpg)\n      ),\n   desc(Avg_mpg)\n )\n```\n\n## Different ways to organize code\n\nOption 3: Use Pipe Operators (Not always available, but you\ncan do it with tidyverse functions)\n\n```{r}\nmtcars %>%\n        filter(carb > 1) %>%\n        group_by(cyl) %>%\n        summarise(Avg_mpg = mean(mpg)) %>%\n        arrange(desc(Avg_mpg))\n```\n\n\n## Tidy Data\n\nThere are three interrelated rules which make a dataset tidy:\n\n- Each variable must have its own column.\n- Each observation must have its own row.\n- Each value must have its own cell.\n\nWe often want data to be in this format for data analysis\n\n## Tidy Data\n```{r  echo=FALSE, out.width = \"100%\"}\nknitr::include_graphics(\"https://d33wubrfki0l68.cloudfront.net/6f1ddb544fc5c69a2478e444ab8112fb0eea23f8/91adc/images/tidy-1.png\") \n```\n\n## Separating and uniting\n\nseparate() pulls apart one column into multiple columns, by splitting wherever a separator character appears. Take table3:\n\n```{r}\ntable3\n```\n\n## Separating\n\n```{r}\ntable3 %>% \n  separate(rate, into = c(\"cases\", \"population\"), sep = \"/\")\n```\n\n\n## Separating\n\n\n```{r}\n#Separate year values after second element of value\n\ntable3 %>% \n  separate(year, into = c(\"century\", \"year\"), sep = 2)\n```\n\n## Uniting\n\nUnite combines two variables into one\n\n```{r}\ntable5[1:2,]\n\ntable5 %>% \n  unite(new, century, year, sep = \"\")\n```\n\n## Joining (merging) data in the Tidyverse\n\n- **Mutating joins**, which add new variables to one data frame from matching observations in another.\n- **Filtering joins**, which filter observations from one data frame based on whether or not they match an observation in the other table.\n- **Set operations**, which treat observations as if they were set elements.\n\nWe will focus on the most common joins, *Mutating Joins*.\n\n## Keys\n\nThe variables used to connect each pair of tables are called keys. \n\n- A *key is a variable (or set of variables) that uniquely identifies an observation*. \n- In simple cases, a single variable is sufficient to identify an observation. \n\nFor example, each plane is uniquely identified by its tailnum. \n\n- In other cases, multiple variables may be needed. \n- For example, to identify an observation in weather you need five variables: year, month, day, hour, and origin.\n\n## There are two types of keys:\n\n- A primary key uniquely identifies an observation in its own table. \n\nFor example, planes$tailnum is a primary key because it uniquely identifies each plane in the planes table.\n\n- A foreign key uniquely identifies an observation in another table. \n\nA variable can be both a primary key and a foreign key. \n\n## Best Practices: Ensure data has unique values on key\n\n- It’s good practice to verify that they do indeed uniquely identify each observation. \n- One way to do that is to count() the primary keys and look for entries where n is greater than one (we want none greater than one):\n\n```{r}\nplanes %>% \n  count(tailnum) %>% \n  filter(n > 1)\n```\n\n\n## Mutating Joins\n\nLets say we want to add a column from the airlines dataset to the following data: \n\n```{r}\nflights2 <- flights %>% \n  select(year:day, hour, origin, dest, tailnum, carrier)\nflights2\n```\n\n## Mutating Joins\n\nLets say we want to add a column from the airlines dataset to the following data: \n\n```{r}\n# the airlines dataset looks like:\nhead(airlines)\n```\n\n## Mutating Joins\n\nTo do so, we would use left_join():\n\n```{r}\nflights2 %>%\n  select(-origin, -dest) %>% \n  left_join(airlines, by = \"carrier\")\n```\n\n## Mutating Joins\n\nThe result of joining airlines to flights2 is an additional variable: name\n\n```{r}\nflights2 %>%\n  select(-origin, -dest) %>% \n  left_join(airlines, by = \"carrier\")\n```\n\n## Types of Mutating Joins\n\nThe simplest type of join is the ***inner join***. An inner join matches pairs of observations whenever their keys are equal:\n\n![Inner Join](https://d33wubrfki0l68.cloudfront.net/3abea0b730526c3f053a3838953c35a0ccbe8980/7f29b/diagrams/join-inner.png)\n\n## Inner Join\n\n```{r}\nx <- tribble(\n  ~key, ~val_x,\n     1, \"x1\",\n     2, \"x2\",\n     3, \"x3\"\n)\ny <- tribble(\n  ~key, ~val_y,\n     1, \"y1\",\n     2, \"y2\",\n     4, \"y3\"\n)\n```\n\n## Inner Join\n\n```{r}\nx %>% \n  inner_join(y, by = \"key\")\n```\n\n## Outer joins\n\nAn inner join keeps observations that appear in both tables. An **outer join keeps observations that appear in at least one of the tables**. There are three types of outer joins:\n\n- A *left join* keeps all observations in x.\n- A *right join* keeps all observations in y.\n- A *full join* keeps all observations in x and y.\n\n## Outer joins\n\n```{r  echo=FALSE, out.width = \"90%\"}\nknitr::include_graphics(\"https://d33wubrfki0l68.cloudfront.net/aeab386461820b029b7e7606ccff1286f623bae1/ef0d4/diagrams/join-venn.png\") \n```\n\n## Outer joins\n\n```{r}\n#leftjoin() with same variable name in two datasets\nflights2 %>% \n  left_join(planes, by = \"tailnum\")\n```\n\n## Outer joins with difft key names\nUse a named character vector: by = c(\"a\" = \"b\"). \n\n- This will match variable a in table x to variable b in table y. The variables from x will be used in the output.\n```{r}\n#leftjoin() with diff't variable name in two datasets\nflights2 %>% \n  left_join(airports, c(\"dest\" = \"faa\"))\n```\n\n## Base R versus Tidyverse Joins\nbase::merge() can perform all four types of mutating join:\n\n*dplyr\tversus merge*\n- inner_join(x, y)\tis equal to  merge(x, y)\n- left_join(x, y) is equal to \tmerge(x, y, all.x = TRUE)\n- right_join(x, y) is equal to \tmerge(x, y, all.y = TRUE),\n- full_join(x, y) is equal to \tmerge(x, y, all.x = TRUE, all.y = TRUE)\n\n## Tidy data using Spread() and Gather\n\nData is often organised to facilitate some use other than analysis. \n\n- For example, data is often organised to make entry as easy as possible.\n\n- This means for most real analyses, you’ll need to do some tidying. \n\n## Tidy data using Spread() and Gather\n\n- The first step is always to figure out what the variables and observations are. \n- Sometimes this is easy; other times you’ll need to consult with the people who originally generated the data. \n\n## Tidy data using Spread() and Gather\n\nThe second step is to resolve one of two common problems:\n\n- One variable might be spread across multiple columns.\n- One observation might be scattered across multiple rows.\n- Typically a dataset will only suffer from one of these problems; it’ll only suffer from both if you’re really unlucky! \n\n## Tidy data using Spread() and Gather\n\nTo fix these problems, you’ll need the two most important functions in tidyr according to Hadley w.: \n\n*gather() and spread().*\n\n## Gathering\n\nTo make the following data \"tidy\" we need to convert our observations to represent country-years. (Unique row = unique country and year values)\nExample data:\n```{r}\ntable4a\n```\n\n## Gathering\n```{r  echo=FALSE, out.width = \"100%\"}\nknitr::include_graphics(\"https://d33wubrfki0l68.cloudfront.net/3aea19108d39606bbe49981acda07696c0c7fcd8/2de65/images/tidy-9.png\") \n```\n\n## Gathering\n\n```{r}\n# Note that columns are numeric, so we use backticks\n# More typically we can just refer to column names.\ntable4a %>% \n  gather(`1999`, `2000`, key = \"year\", value = \"cases\")\n```\n\n## Spreading\n\nSpreading is the opposite of gathering. You use it when an observation is scattered across multiple rows. \n\nHow would you make the following data tidy?\n```{r}\ntable2\n```\n\n## Spreading\n- The variable we want to create new columns with is the key.\n- The variable we want to specify as our values is the value\n```{r}\ntable2 %>%\n    spread(key = type, value = count)\n```\n\n## Spreading\n```{r  echo=FALSE, out.width = \"100%\"}\nknitr::include_graphics(\"https://d33wubrfki0l68.cloudfront.net/8350f0dda414629b9d6c354f87acf5c5f722be43/bcb84/images/tidy-8.png\") \n```",
    "created" : 1559740699305.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3254641557",
    "id" : "D243970F",
    "lastKnownWriteTime" : 1559736958,
    "last_content_update" : 1559742838567,
    "path" : "~/Downloads/Class 2 - Intro to the Tidyverse.Rmd",
    "project_path" : null,
    "properties" : {
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_markdown"
}